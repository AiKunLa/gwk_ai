# 闭包
## 概念
- 闭包就是函数嵌套，内部函数访问外部函数的变量
- 闭包是指有权访问另一个函数作用域中的变量（自由变量）的函数。
- 内部函数被称为闭包函数，外部函数被称为宿主函数
- 
## 形成
 - 1. 函数嵌套函数 ——》 形成作用域链的嵌套 fn2在fn1的里面形成了一个闭包 在函数被执行后函数被销毁但是自由变量不会被销毁 会在背包中 闭包也叫背包
    为什么自由变量不会被销毁
    - 这是由于函数执行的先后顺序带来的，内层函数引用了外层函数的变量，其引用计数会加1,这会使得该变量的引用计数不为0，所以不会被销毁。
    - 由于垃圾回收机制会根据引用的数量来判断是否回收内存 若引用的数量为0 则会回收内存 若引用的数量不为0 则不会回收内存 所以自由变量不会被销毁。
    什么是时候自由变量会销毁
    - 
 - 2. 内部函数引用外部函数的变量
    - 若内部函数引用了外部函数的变量 则会形成一个闭包  若内部函数没有引用外部函数的变量 则不会形成一个闭包
 - 3. 外部函数返回内部函数 ——》 
function fn1(){
    var n = 100
    function fn2(){
        console.log(n)
    }
    return fn2
}
var res = fn1()
res()

## 如何证明自由变量没有被销毁
- 多次执行闭包函数，来观察
function f1() {
  var n = 99;
  nAdd = function () {
    n++;
  };
  function f2() {
    console.log(n);
  }
  return f2;
}
// 上述有几个闭包函数
var test = f1();
test()//99
nAdd()
test()//100


## 作用域
- 全局作用域
    - 全局变量
    - 全局函数
- 函数作用域
    - 函数变量
    - 函数函数
- 块级作用域
    - let
    - const

var n = 99
function fn() {
    // 
    b = 100
    // 函数作用域
    var n = 10
    console.log(n,b)
}
fn()
上述代码中
- b是全局变量  在非严格模式下 若一个变量未声明 就赋值  那么这个变量就会变成全局变量
- n是函数变量
- 函数fn就是一个闭包


## 函数外部无法查找函数内部的变量- 但通过闭包可以


## 为什么自由变量不会被销毁
- 这就要了解js执行栈
- 因为闭包会使函数的作用域链不被释放，所以自由变量不会被销毁。


## 闭包的应用
- 1. 记忆函数
    使用js闭包 记忆函数的执行结果
    - memoizeFib外层函数执行 返回内层函数
- 2. 柯里化
    

## 注意
- 闭包内存消耗比较大，可能导致内存泄漏
 在退出函数之前，将不使用的局部变量销毁 = null  delete

- 闭包会在父函数的外部，改变父函数内部变量的值
**自由**变量
 不确定性：变量的内容或数据类型处于变化中 
 生命周期：你不知道它什么是被销毁
