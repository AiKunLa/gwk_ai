# 闭包的应用
闭包可以用来实现一些功能，比如：
- 绑定上下文
    箭头函数
    that=this
    bind
- 模拟私有变量
- 柯理化函数
- 函数防抖和节流
- 异步编程
- 记忆函数
- 偏函数
- 立即执行函数

## 模拟私有变量
1. 私有变量：变量不能被外部直接访问和操作，可以通过返回对象提供的方法来操作它。这样可以防止外部代码随意修改类的状态，这有助于确保对象的数据完整性，避免因错误赋值导致的问题。
    将类的内部状态隐藏起来，只暴露必要的接口给外部使用，这种机制称为封装


2. 闭包实现类的封装，函数内部返回对象，**这个对象里面有一些方法，这些方法可以访问函数内部的变量，但是外部不能直接访问这些变量。**
    ```js
        function CreateCounter(num) {
          this.num = num;
          let count = 0;
          return { // 这样就创建了一个类，count是私有变量，name是公有变量
            name:'计数器',
            increment: () => {
              count++;
            },
            decrement: () => {
              count--;
            },
            getCount: () => {
              return count;
            },
          };
        }
        const obj = CreateCounter(1);
        console.log(obj.getCount());
    ```
    类封装了属性和方法
        - 对内 private保护了隐私，隐藏了业务复杂性
        - 对外提供了接口API，方便外部使用






## 防抖节流
为什么要防抖节流
1. 防抖 debounce
    **只有在停止触发后才执行一次**
    防抖的思路是：当某个事件被触发时，设置一个定时器，在指定的时间间隔后执行特定的函数。
    如果在定时器到期之前该事件又被触发，则重置定时器，重新计时。
    只有当事件停止触发超过设定的时间间隔时，才会真正执行该函数。

2. 节流 throttle
    **一段时间内触发一次**，适用于scroll
    节流的思路是：当某个事件被触发时，设置一个定时器，在指定的时间间隔内只执行一次该函数。
    如果在定时器到期之前该事件又被触发，则忽略该次触发，直到定时器到期后再次触发。
    节流可以用来优化一些高频触发的事件，比如滚动事件、窗口调整事件等。
