# 历史
- const声明常量，es5时期没有专门的常量声明
声明简单数据类型时不可以改变值
声明对象时，其指向的内存地址不可以改变
为什么const声明对象时，其指向的内存地址不可以改变？
因为const声明的是一个指针，这个指针指向的内存地址是不可以改变的，但是这个指针指向的内存地址中的值是可以改变的。
- let声明变量，es6
- var声明变量，es5


当使用 const 声明对象，实际上是声明了一个常量指针，该指针指向对象所在的内存地址。一旦初始化，指针就不能再指向其他内存地址，但可以通过该指针修改对象内部的属性值。

## 为什么const声明简单数据类型时不可以改变值？
它们是按值存储在栈内存中的。当使用 const 声明简单数据类型时，这个绑定会被固定，不允许重新赋值。

## 为什么const声明对象时，其指向的内存地址不可以改变但是值可以改变？
const 声明的引用类型的变量与栈内存中的地址是一种固定的引用关系，而不是指向堆内存中的地址。
当使用 const 声明一个对象时，实际上是声明了一个常量引用，也就是一个指向对象所在内存地址的指针。 const 关键字保证这个引用是不可变的，一旦初始化之后，这个引用就不能再指向其他内存地址

- 栈内存和堆内存的区别：
-- 栈内存：
栈内存是一种线性数据结构，用于存储函数调用和局部变量。
栈内存的分配和释放是自动的，由编译器管理。
栈内存的大小是固定的，通常由操作系统分配。
栈内存的访问速度非常快，因为它是连续的内存空间。
栈内存的生命周期是由函数调用和返回决定的。
-- 堆内存：
堆内存是一种动态分配的内存空间，用于存储动态分配的对象和数据。
堆内存的分配和释放是由程序员手动控制的。
堆内存的大小是可变的，由操作系统管理。
堆内存的访问速度相对较慢，因为它是不连续的内存空间。


对象属于引用类型，存储在堆内存中。 const 只是保证引用本身不变，并不限制对象内部属性的修改。
当我们通过引用访问对象的属性并修改它们时，实际上是在修改堆内存中对象的状态，而引用本身指向的内存地址并没有改变。

对象属于引用类型，存储在堆内存。使用 const 声明对象时，实际上是声明了一个常量引用（指针），该引用指向对象在堆内存中的地址。
变量名会在栈内存中存储一个引用（指针） 

const friend = [{}]

friend 与栈内存中的地址是一种固定的引用关系， const 保证了这个引用地址的不可变性，但允许通过该引用对堆内存中的对象进行修改。

对于不变的，将其放到栈内存中，对于可能改变的，将其放到堆内存中。




# es6 第一个新特性 let const ，弥补了es5的只有var的不足，支持块级作用域（有什么用） 支持常量
因为早期的js是用来设计页面交互的（若类型，单线程，交互），es6的目标是要js成为企业级别的大型应用开发语言，和java C++ 一样，
所以块级作用域是需要的
TDZ解决了变量提升的问题，变量提升的缺点是会导致变量污染，变量重复声明，可读性差，执行有歧义
TDZ如何解决变量提升的问题？：

- 什么是块级作用域？ 
块级作用域是指在花括号内定义的变量，只能在花括号内访问，外部无法访问。
为什么要支持块级作用域？
- 避免变量提升
- 避免变量污染
- 避免变量重复声明
- 避免变量重复定义
- 避免变量重复赋值
- 避免变量重复使用

- 块级作用域的作用
 是大型语言的需要
 for 等...
- 变量的内存分配
 内存栈：js 执行上下文分配内存的主要场所，栈内存是由高地址向低地址分配的，栈内存的大小是固定的，通常由操作系统分配。（第一战场，在内存中是连续的）
 内存堆：堆内存是由低地址向高地址分配的，堆内存的大小是可变的，由操作系统管理。（第二战场，不连续）
 内存队列：队列内存是由低地址向高地址分配的，队列内存的大小是可变的，由操作系统管理。
 内存常量池：常量池是由低地址向高地址分配的，常量池的大小是可变的，由操作系统管理。

- 简单数据类型 const 声明后值不可以改变
- 引用数据类型 const 声明后指向的内存地址不可以改变，但是值可以改变
- var 在前端声明的变量会挂在window（js顶级对象）上，let const 不会 var 会污染window对象，这是不合理的，let const 不会提升，
- 赋值

# 考题