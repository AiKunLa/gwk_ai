# 反转链表
如何表达这个算法思想
- 反转链表的算法思想是：将链表的每个节点的指针指向前一个节点，从而实现链表的反转。

- 需要把**单项**链表反转

- 迭代实现，时间复杂度O(n)，空间复杂度O(1)
    - 迭代实现的核心思想是：通过改变每个节点的指针指向前一个节点，从而实现链表的反转。
    重点讲清楚指针的变化过程 
    - 定义三个指针：pre、cur、next
    - 初始化：pre = null, cur = head, next = null

    使用next存储下一个要反转的节点，然后将当前节点的next指针指向前一个节点，之后将pre指向当前节点，cur指向当前节点的下一个节点也就是next指向的节点。一直这样直到cur为空
    - 遍历链表，每次循环：
        - next = cur.next
        - cur.next = pre
        - pre = cur
        - cur = next
    - 遍历结束，pre 指向新的头节点

-递归方法解决
    如何表达这个算法思想
    - 这种是从后向前反转链表，将问题拆分成小。先走到最后的节点，然后从后向前反转链表
        对于每个节点，我们将node.next.next 指向 node，然后将node.next 指向 null，这样就完成了局部反转
        递归终止条件是当前节点或者下一个节点为空，返回当前节点
        
    