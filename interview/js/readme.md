
# 1. 深拷贝和浅拷贝
等号对于简单数据类型赋的是值，对于复杂数据类型赋值的是引用。
1. 浅拷贝：只复制对象的引用，而不复制对象本身。
- 浅拷贝的实现方式有：
  - Object.assign(target, ...sources)
    这个方法用于将一个或者多个源对象的所有**可枚举(Symbol 也会被拷贝)**属性，复制到目标对象上,并返回修改后的目标对象。
    它并没有创建一个新的对象，而是修改了目标对象, 目标对象与返回的对象是同一个对象。
    若目标对象中的属性与源对象中的属性同名，则目标对象中的属性会被源对象中的属性覆盖。（后来居上）
    常用于浅拷贝和   不支持深拷贝
    若对象的层次比较深，则浅拷贝只会拷贝对象的第一层，后面的层次还是引用原来的对象。若修改了目标对象的属性，源对象的属性也会被修改。它不安全

    **注意点**
    若原对象是简单数据类型，他会忽略。若目标对象是简单数据类型则会报错
    目标对象必须是一个对象
    若不传递第二个参数，则也不会报错，但是不会拷贝任何属性

    **项目中的具体使用**
    应用场景：
    - 合并默认参数
    - 合并配置对象

  - 展开运算符（...）
  - Array.prototype.slice() // 用于切割数组，返回一个新数组
  - Array.prototype.concat() // 用于合并数组，返回一个新数组

2. 深拷贝：复制对象本身，而不是对象的引用。他是递归拷贝所有层
- 深拷贝的实现方式有：
  - JSON.parse(JSON.stringify(obj)) 将原对象序列化成JSON字符串，然后再将JSON字符串反序列化成对象。
  - 递归拷贝
  - lodash库的_.cloneDeep()方法

- 面试官的想法
  深拷贝，浅拷贝是核心必考内容
  以Object.assign() 方法来开场
  - 面试是当面展示自己的一个过程，表演要有一个过程
    从AIP细节 ——》 浅拷贝 业务场景，在开发之中是如何使用的。——》 赋值引用，基本数据类型和引用数据类型是不同的 ——》 底层原理 ——》 
    
    使用JSON.parse(JSON.stringify(obj)) 来实现深拷贝时，它的问题在于不能拷贝函数（函数不知道如何序列化），Symbol、undefind（JSON会忽略它，它不支持）、循环引用
    JSON序列化的规则  undefined function Symbol都不是合法的JSON值，所以会被忽略。
    - 手写深拷贝
      赋值和引用的概念
    ——》 手写深拷贝
3. 浅拷贝使用
    Object.assign()   数组方法 slice() contact()
   浅拷贝解决不了的使用深拷贝，JSON.parse(JSON.stringify(obj))  
   若序列化解决不了则使用手写




# 2. 响应式的底层
响应式开发是，当数据状态发生改变时，数据绑定的地方会自动更新
对MVVM的理解
Model Count View 
对象 属性 对象（其中包含了操作这个对象会执行的方法）
通过这个AIP我们可以精确的控制对象属性的定义和行为，并且在完成本来职责的同时去做dom更新，这就是响应式
- Object.defineProperty(obj,'value',{
  get(){
    return value
  },
  set(newValue){
    value = newValue
  }
})

- 这个方法的缺点
  它很麻烦，每次只能定义一个属性
  使用Propx代理
  它可以代理整个对象，并且其代理的行为很多

- 对比 Proxy 比较新，对浏览器版本有要求，而defineProperty 对浏览器的兼容性更好

- 属性描述符（property descriptor）
  configurable: false, // 这个属性的配置是否可以更改  是否可修改或者删除

