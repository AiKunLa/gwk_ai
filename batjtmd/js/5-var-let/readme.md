# 
var a = 10;
(function a() {
  a = 20;
  console.log(a);
})
();

- 上述的结果是function

## 函数的声明
- 返回结果是函数本身
- 如果是严格模式则报错Assignment to constant variable.
- 对js更加严格
  函数名a在函数体内部是局部变量，它是只读的，因为函数的优先级高于变量的优先级
  虽然js是弱类型语言，可以随意修改变量的值，但是函数在函数体内部是只读的，不能修改

## js运行环境有哪些
- 严格模式 ：在严格模式中
- 浏览器环境 （一般以这个为主）
- node环境
- web worker环境

## 为什么var 声明的变量会在前端挂载到window对象上
- 全局变量和顶层对象的属性是等价的
- 在浏览器中顶层对象就是window对象。但是在node环境中，顶层对象是global对象
- 在es5之前 全局全局变量和顶层对象的属性是等价的 但这样会污染顶层对象
- es6 let const 全局变量会怎样？会放在那里 
 - 在es6中，let const 声明的全局变量不会挂载到顶层对象上，而是在块级作用域中，最顶级的作用域块，<script></script> 脚本块
 - 使用断电调试来查看变量的作用域

## this
- this是什么
 函数**执行**的时候，会立即生成的对象，这个对象就是this （this由调用方式决定）
- this指向
 函数执行时，this指向调用它的对象
- this指向变化
 1. 函数调用时，this指向调用它的对象
 2. 函数作为对象的方法调用时，this指向该对象

- 函数的调用方式
 - 普通函数调用 eg: fn()  相当于window.fn()  严格模式下this指向undefined，因为它认为this指向window没有必要 
 - 方法调用 eg: obj.fn()
 - 构造函数调用 eg: new fn() 指向实例对象
 - 箭头函数调用 eg: () => {}  箭头函数本身没有this 指向箭头函数的上一级作用域的this
 - 事件回调函数调用 eg: btn.onclick = function() {} 指向事件源对象

## 立即执行函数
