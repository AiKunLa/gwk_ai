# 什么是异步编程

异步编程是指允许程序在发起一个可能耗时时的操作后，不必等待这个操作完成，而是继续执行后续代码。当这个操作最终完成时，系统会通过某种机制来通知程序，并执行相应的处理逻辑

常见的异步编程方式用
    - 回调函数
        通过回调函数在任务完成后执行的一种函数，回调函数有回调地狱的问题、和错误难以传递的问题  
    - Promise 链式调用，管理异步流程、支持链式、统一错误捕获 .then/.catch/.finally，链式过多会导致可读性下降
    - async/await
        Promise的语法糖，用同步写法实现异步逻辑，接近同步风格
        要配合try catch finally 来捕获错误

        await在等啥，他等的本质是一个表达式的结果，通常式一个Promise。
        如果式promise，js会暂停当前async函数的执行，把后续代码放入微任务中，直到该任务resolve/reject 后在继续。 如果式非Promise值，会被Promise.resolve（）包装成Promise对象。立即继续执行

        await后面不一定式promise，会用Promise.resolve() 来包装

    - Generator + yield 可以暂停的生成器函数
        异步流程控制灵活
        但是需要手动的执行控制，调用next() 来执行下一个yield表达式
        
        一段时间后被async/await取代
    - 事件/发布订阅 事件触发后异步执行监听
    - webworker 开闭了子线程执行耗时任务，是真正并行
        在子线程中不能操作DOM，不能访问window对象
        基于事件机制通信

JavaScript是单线程的，异步是为了解决堵塞。从早期回调到Promise，再到async/await，核心都是基于事件循环和任务队列，让耗时任务放入异步队列，主线程继续执行

我更加倾向于使用async/await ，他的语义清晰且能优雅的处理错误

- 进程和线程的区别
    进程操作系统进行资源分配的最小单位，是一个程序的执行实例，有独立的内存空间（堆、栈、代码等）。
    线程是CPU调度和执行的基本单位，是进程内的一个执行流程
    一个进程可以包含多个线程，这些线程共享进程的内存空间和资源。

    资源开销
        进程之间是互相独立的，切换和开销大；线程属于同一进程，共享资源，切换开销小。
    内存隔离
        进程有独立的地址空间，一个进程崩溃不会影响其他进程
        线程共享进程内存，一个线程出错可能影响其他线程。浏览器的每一个Tap都是一个进程，若一个tap崩溃，不会影响其他的进程
    通信
        进程之间的通信IPC比较复杂，需要通过管道、消息队列
        线程之间可以通过共享变量通信
    浏览器多进程架构，每个标签页、插件、GPU 都有自己的进程

    死锁
        两个线程属于同一个进程，可以访问进程的共享内存，若以可以读写同一变量
        当有两个线程，都需要两把锁（A和B）
            线程1 拿着A 等待B
            线程2 拿着B 等待A
    Http 属于计算机网络的那一层
        它属于应用层 负责定义客户端与服务器之间的通信规则和数据格式
        应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
        http1.0可以同时发送多个请求，但是依然是串行

        http2.0多路复用，引入帧，将流分解成多个帧，可以交叉发送，假设一个 TCP 连接上同时传输着 10 个流（Stream）的数据帧。如果其中一个流的某个数据包丢失了，那么所有 10 个流的处理都会被阻塞

        http3.0由于TCP是一种可靠的传输，如数据丢失则需要重新发送，3.0引入QUIC，基于UDP。每个流都是独立的。UDP本身是无连接的， 当 QUIC 检测到某个流的数据包丢失时，它只需要重传该流的数据包。其他流的数据包可以继续正常传输和处理。这彻底解耦了流之间的依赖关系。

    TCP 与 UDP
        TCP是可靠的面向链接的，每个数据都有一个序列号，按序接收。每收到数据，就会发送一个接收信号ACK，若发送方没有收到信号，则会重新发送数据
        UDP是不可靠无连接的，发送数据后，不管接收方是否准备、不管数据是否到达。若数据包丢失，UDP不会重传

        网页浏览必须使用TCP，因为若一个html丢失了些许字节，有可能导致标签没有闭合，或者css规则不完整，导致整个页面无法加载或者崩溃
