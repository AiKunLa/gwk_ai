<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      Function.prototype.myCall = function (context, ...args) {
        // rest运算符，将参数转化为数组
        // typeof null  为Object  以为以二进制前三位来判断的   只能由object
        // 只会对除null之外的简单数据类型 和function 判断准确
        // 这里的this指向的是
        if (typeof this !== "function") {
          // 这是为了防止非函数调用myCall
          throw new TypeError("Error");
        }

        context = context || window; // context为null或undefined时，this指向window

        // 使用Symbol 生成一个唯一的属性名，避免与对象原有属性冲突，这里的原有属性指的是context对象原有属性
        const fnKey = Symbol("fn"); // 生成一个唯一的绝对不重复的，避免与对象原有属性冲突
        
        console.log(this) // this 
        context[fnKey] = this; // 将目标函数（ this ）临时挂载为 context 对象的一个属性（ fn ）。

        console.log(context[fnKey])
        
        const result = context[fnKey](...args); // 展开运算符，将数组转化为参数列表

        /**
        * - 通过 context.fn = this ，将目标函数（ this ）临时挂载为 context 对象的一个属性（ fn ）。
        - 后续通过 context.fn(...) 调用函数时，函数内部的 this 自然会指向 context ，从而实现 this 指向的显式绑定。
        */

        delete context.fn; // 删除context的fn属性
        return result; // 返回函数执行的结果
      };

      const pers = {
        name: "张三",
        age: 18,
        say() {
          console.log(this.name);
        },
      };
      function fn(a, b) {
        console.log(a + b);
      }
      
      fn.myCall(pers, 1, 2);
    </script>
  </body>
</html>
