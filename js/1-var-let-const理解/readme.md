# var_let_const
## js代码执行机制
- 有一段代码——本质是文本
- 从硬盘中读入内存
- V8引擎——Chrome的心脏，负责解析和执行代码（主持工作）
- 进入编译阶段
- 1.准备代码执行环境 
  - 创建全局上下文：globalContext{showName:'',}（全局上下文）
  - 创建变量环境：currentVariableEnvironment{showName:'',}（当前执行环境）globalVariableEnvironment（全局执行环境）这样的结构，用于 存储当前全局作用域下的变量。
  - 确定作用域（变量查找（访问）的规则）——全局、函数、块级
  - 创建作用域链（变量查找的路径）先查找当前执行环境，再查找全局执行环境（当前作用域——》父作用域...——》全局——》报错）。层层递进的嵌套关系
  - 冒泡查找环境中的变量

 全局上下文


- 变量提升 hoisting 提升的是变量的声明，而不是变量的赋值（赋值是再执行阶段做的） 所以它的值是undefined。
- 函数提升的是函数的定义
- 执行代码
- 2.执行代码
  - 执行上下文：代码执行的环境，包含了代码执行时的变量环境、作用域链、this值等信息。
  - 执行上下文栈：用于管理执行上下文的栈结构，用于存储当前执行上下文和其相关的执行上下文。

- 3.调用栈
 - 
## 为什么let不行 没有变量提升
var的变量提升导致代码的执行结果和代码阅读顺序不一致，有歧义。所以现在不在使用var声明变量而用let
console.log(a) //undefined
let a = 10;
 - let 支持块级作用域，没有变量提升，所以会报错。
 - let提供了 TDZ 暂时性死区，在声明之前访问变量会报错。
 - 词法作用域：
 - 词法环境里面有一个TDZ
