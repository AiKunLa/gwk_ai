# event loop
Event Loop（事件循环）是JavaScript运行时环境（如浏览器和Node.js）中的一种机制，用于实现非阻塞代码的执行。
调用栈      任务队列    事件循环
首先执行一个宏任务，然后执行微任务，

1. js是单线程
    同一时刻只能做一件事
    同步任务需要尽快执行完，以便于页面的呈现

2. 宏任务与微任务
    一个script就是一个宏任务开始，在这个宏任务中有异步任务和同步任务。为了将这个宏任务快速执行完，会跳过异步任务并将其放入到event loop中

    - 执行顺序
        首先执行当前宏任务中的同步代码。
        当前宏任务完成后，事件循环检查并执行所有微任务队列中的任务，直到微任务队列为空。
        微任务全部执行完毕后，事件循环将选择下一个宏任务执行，并重复上述过程。

3. 微任务和宏任务分别由那些
    - 微任务 (发生在页面渲染之前，可以看作同步任务执行之后的一个补充)
        promise.then()
        MutationObserver （dom改变在页面渲染之前，可以在页面渲染之前就拿到改变的dom）
        process.nextTick() 比 promise.then() 先执行
        queueMicrotask() 微任务队列


## 进程与线程
cpu轮循
- 进程： **cpu分配资源的最小单位**
    分配内存与cpu处理的机会
    每个进程有着独立的内存空间和进程id，一个进程崩溃不会影响其他进程。程序运行以进程为单位
    主进程（负责管理、协调、沟通子进程）
        负责管理子进程，从而可以实现并发、并行
        进程之间的通信

    **进程中有主线程**
        js同步代码是在主线程中执行的
        



    进程之间的通信
        两个独立进程之间的通信开销大
        父子进程之间的通信开销较小

- 线程： cpu调度的最小单位
    干活的
- 浏览器是多进程架构的
    启动后会有一个主进程（负责协调、沟通、管理子进程）
    一个tab 就是一个渲染进程，几个tab就有几个进程。进程之间互不干扰，一个进程的崩溃不会影响其他进程，这样很安全

    渲染进程中有主线程
        主要线程中执行js同步代码，渲染页面
        主线程的工作内容：
            解析html 构建DOM树
            解析css 构建cssom树
            合并DOM树和cssom树 构建渲染树
            生成layout布局树 计算每个元素的位置和大小
            合并图层
            v8 引擎执行js

        event loop
            事件队列
                - 定时器到点了
                - onreadystatechange
        微任务全部执行

        **页面更新**，这里有着独立的线程来执行 
            渲染在为什么会在这个位置，js执行与渲染是互斥的（因为处于同一线程）。js先执行，js执行完毕后再进行渲染（绘制是交给独立线程的），这是应为


        再次取出宏任务

        为什么js是单线程
            这样简单
            若多个js脚本同时操作DOM，这样可能会导致状态不一致

        
        执行栈就是在主线程中执行的，声明异步任务的代码是同步的，声明异步任务后会有线程将其放入到任务队列中
        event loop 也在主线程中执行

        - setTimeout 会有专属定时器线程
            这个线程会将这个异步任务放入到event loop的宏任务队列中，即使定时器的时间到了也不一定会立即执行，因为队列前面可能还有宏任务，或者微任务队列还没有清空。
            
            若一个两秒的定时器比一个一秒的定时器先声明那么哪个先入队列？
                加入队列的先后顺序取决于专属线程的调度，

            那么这些宏任务或微任务中的回调函数是如何执行的？
                以进入执行栈为标志

        - addEventListener 没有独立的线程 主线程操作他



